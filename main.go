// This code is released under the MIT License
// Copyright (c) 2020 Pix4D and the terravalet contributors.

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/integrii/flaggy"
)

var (
	// Filled by the linker.
	fullVersion  = "unknown" // example: v0.0.9-8-g941583d027-dirty
	shortVersion = "unknown" // example: v0.0.9
)

func main() {
	planPath := ""
	localStatePath := "local.tfstate"

	flaggy.SetDescription("A simple valet for terraform operations (WIP).")
	flaggy.AddPositionalValue(&planPath, "plan", 1, true, "Path to the output of terraform plan.")
	flaggy.String(&localStatePath, "", "local-state", "Path to the local state to modify (both src and dst).")

	flaggy.SetVersion(fullVersion)
	flaggy.Parse()

	inFile, err := os.Open(planPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "reading the tf plan file: %v\n", err)
		os.Exit(1)
	}
	defer inFile.Close()

	outFile := os.Stdout

	create, destroy, err := parse(inFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "parse: %v\n", err)
		os.Exit(1)
	}

	matches, err := match(create, destroy)
	if err != nil {
		fmt.Fprintf(os.Stderr, "match: %v\n", err)
		os.Exit(1)
	}

	if err := script(matches, localStatePath, outFile); err != nil {
		fmt.Fprintf(os.Stderr, "creating script: %v\n", err)
		os.Exit(1)
	}
}

func parse(rd io.Reader) ([]string, []string, error) {
	// " # module.ci.aws_instance.docker will be destroyed"
	// " # aws_instance.docker will be created"
	// " # module.ci.module.workers["windows-vs2019"].aws_autoscaling_schedule.night_mode will be destroyed"
	// " # module.workers["windows-vs2019"].aws_autoscaling_schedule.night_mode will be created"

	var re = regexp.MustCompile(`# (.+) will be (destroyed|created)`)

	var create []string
	var destroy []string

	scanner := bufio.NewScanner(rd)
	for scanner.Scan() {
		line := scanner.Text()
		if m := re.FindStringSubmatch(line); m != nil {
			if len(m) != 3 {
				return create, destroy,
					fmt.Errorf("could not parse line %q: %q", line, m)
			}
			// for debugging:
			// fmt.Printf("%q\n", m[0])
			// for i := 1; i < len(m); i++ {
			// 	fmt.Printf("    %q\n", m[i])
			// }
			switch m[2] {
			case "created":
				create = append(create, m[1])
			case "destroyed":
				destroy = append(destroy, m[1])
			default:
				return create, destroy,
					fmt.Errorf("line %q, unexpected action %q", line, m[2])
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return create, destroy, err
	}

	// fmt.Printf("create len: %d\n", len(create))
	// fmt.Printf("create: %v\n\n", create)

	// fmt.Printf("destroy len: %d\n", len(destroy))
	// fmt.Printf("destroy: %v\n\n", destroy)

	return create, destroy, nil
}

func match(create, destroy []string) (map[string]string, error) {
	// old -> new (or equvalenty: destroy -> create)
	matches := map[string]string{}

	// 1. create and destroy give us the direction:
	//   terraform state mv destroy[i] create[j]
	// 2. but, for each resource, we need to know i,j so that we can match which old state
	//    we want to move to which new state, for example both are theoretically valid:
	// 	    terraform state mv module.ci.aws_instance.docker           aws_instance.docker
	//      terraform state mv           aws_instance.docker module.ci.aws_instance.docker

	for _, d := range destroy {
		for _, c := range create {
			if strings.HasSuffix(c, d) || strings.HasSuffix(d, c) {
				matches[d] = c
				break
			}
		}
	}
	return matches, nil
}

func script(matches map[string]string, statePath string, out io.Writer) error {
	fmt.Fprintf(out, "#! /usr/bin/sh\n")
	fmt.Fprintf(out, "# DO NOT EDIT. Generated by terravalet version %s.\n", fullVersion)
	fmt.Fprintf(out, "#\n")
	fmt.Fprintf(out, "# This script will move %d items.\n\n", len(matches))
	fmt.Fprintf(out, "set -e\n\n")

	cmd := fmt.Sprintf("terraform state mv -state=%s", statePath)
	total := len(matches)

	// Go maps are unordered. We want instead a stable iteration order, to make it
	// possible to compare scripts.
	destroys := make([]string, 0, len(matches))
	for d := range matches {
		destroys = append(destroys, d)
	}
	sort.Strings(destroys)

	i := 1
	for _, d := range destroys {
		fmt.Fprintf(out, "echo \">>> %d/%d\"\n", i, total)
		fmt.Fprintf(out, "%s \\\n    '%s' \\\n    '%s'\n\n", cmd, d, matches[d])
		i++
	}
	return nil
}
